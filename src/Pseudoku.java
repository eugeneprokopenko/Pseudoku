import javafx.application.Application;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.stage.Stage;
import java.util.*;
import javafx.scene.control.TextField;
import javafx.scene.text.Text;
import javafx.event.*;
import javafx.geometry.Insets;
import javafx.scene.paint.Color;
import javafx.scene.control.Label;
import javafx.scene.layout.*;
import javafx.scene.shape.Line;
import javafx.scene.input.*;
import javafx.scene.control.CheckBox;
import javafx.scene.control.ScrollPane;


public class Pseudoku extends Application {

	// test counter
	// public static int testCounter = 0;

	// N represents number of big blocks. This program refers to "big blocks"
	// and "big boxes" interchangeably. They mean the same thing.
	public static int N;

	// Pixel size of one small block in the grid. This program refers to "small
	// blocks," "small boxes," and "points" interchangeably
	public static final int BOX_HEIGHT = 30;

	// the big master 2D matrix box values and their summations,
	// as well as information about lines and equation variables
	public static CustomBox[][] twoDArray;

	// master pane
	public static BorderPane masterPane = new BorderPane();

	// pane that contains grid visual of the matrix
	public static Pane centerPane = new Pane();

	// this will hold the centerPane and allow the matrix to grow larger than screen size
	public static ScrollPane scrollPane = new ScrollPane();

	// pane that displays a list of equations
	public static VBox equationBox = new VBox();

	// pane that displays terminal for auto-generation of matrices
	public static VBox autoGenerationBox = new VBox();

	// pane that displays Solve! button at the bottom of the screen
	public static HBox bottomPane = new HBox();

	// a list of equations generated by values in the matrix
	public static ArrayList<Equation> equationList = new ArrayList<>();

	public static Stage primaryStage = new Stage();

	// a textbox that shows how many points have been found by auto-generation
	public static Text pointsFound = new Text("");

	// a textbox that shows how many vetices have been found by auto-generation
	public static Text verticesFound = new Text("");

	// a textbox that shows how many points have been checked by auto-generation
	public static Text pointsChecked = new Text("");

	// This is an invisible button, kind of a "cheat," that is "pushed" by the
	// code of the AutoGeneration class and is a way for other classes
	// to access variables within this JavaFX start method.
	public static Button pauseAutoGenerationButton = new Button("Pause Auto Generation");


	// If checked, then the autogeneration algorithm will only save one found vertex per family,
	// as opposed to all vertices found. It is public because it is accessed by the AutoGeneration class.
	public static CheckBox onePerFamilyCheckBox = new CheckBox("Save only one vertex per family.");

	// screen becomes locked after the Lock In Values button is pressed.
	public static boolean screenLocked = false;

	public void start(Stage stage) {

		// sets N equal to an integer chosen by user
		obtainNValueFromUser();

		// create a two dimensional array of proper size
		twoDArray = new CustomBox[N * N + 1][N * N + 1];

		// sets values in the matrix and creates a visual representation of
		// itself
		initializeMatrixAndGrid();

		// make some space between the equation list and the grid
		equationBox.setPadding(new Insets(0, 5, 0, 5));
		autoGenerationBox.setPadding(new Insets(0, 5, 0, 5));
		equationBox.setMinWidth(N * 2 * BOX_HEIGHT);


		Button setSaveDirectoryButton = new Button("Set Save Directory");
		Button openFileButton = new Button("Open File");
		Button openButton = new Button("Open");
		Button saveButton = new Button("Save");
		Button lockInValuesButton = new Button("Lock-In Values");
		Button stepButton = new Button("Step");
		Button beginAutoGenerationButton = new Button("Begin/Continue Auto Generation");
		Button resetButton = new Button("Reset");
		Button solveButton = new Button("Solve!");

		// text field where a multiple of shape point, at which the program pauses, checked is specified
		TextField multipleOfCounterInput = new TextField("1000");
		multipleOfCounterInput.setMaxWidth(100);


		onePerFamilyCheckBox.setAllowIndeterminate(false);
		onePerFamilyCheckBox.setSelected(true);


		// a textbox that explains why the multipleOfCounterInput text field is
		// present
		Text textFieldExplanation = new Text("Pause every ___ matrices checked: ");

		// initially disable some of the buttons
		beginAutoGenerationButton.setDisable(true);
		stepButton.setDisable(true);

		// if a valid file path exists, then the auto-lock button is enabled,
		// otherwise not
		if (AutoGeneration.autoGenerationSavePath == null) {
			lockInValuesButton.setDisable(true);
		} else {
			lockInValuesButton.setDisable(false);
		}



		setSaveDirectoryButton.setOnAction(new EventHandler<ActionEvent>() {
			public void handle(ActionEvent t) {


				AutoGeneration.autoGenerationSavePath = OpenSave.getDirectory();

				if (AutoGeneration.autoGenerationSavePath != null) {
					lockInValuesButton.setDisable(false);
				}

			}
		});

		openFileButton.setOnAction(new EventHandler<ActionEvent>() {
			public void handle(ActionEvent t) {

				OpenSave.openMatrixByUser();

			}
		});

		openButton.setOnAction(new EventHandler<ActionEvent>() {
			public void handle(ActionEvent t) {

				OpenSave.openMatrixByUser();

			}
		});

		saveButton.setOnAction(new EventHandler<ActionEvent>() {
			public void handle(ActionEvent t) {

				OpenSave.saveMatrixByUser();

			}
		});

		lockInValuesButton.setOnAction(new EventHandler<ActionEvent>() {
			public void handle(ActionEvent t) {

				beginAutoGenerationButton.setDisable(false);
				stepButton.setDisable(false);
				lockInValuesButton.setDisable(true);

				equationBox.getChildren().add(new Text("Screen has been locked."));
				equationBox.getChildren().add(new Text(""));

				screenLocked = true;

				AutoGeneration.lockInValues(twoDArray);

			}
		});

		stepButton.setOnAction(new EventHandler<ActionEvent>() {
			public void handle(ActionEvent t) {

				AutoGeneration.multipleOfShapePointCounter = Integer.parseInt(multipleOfCounterInput.getText());

				if (!AutoGeneration.done) {
					AutoGeneration.continueAutoGeneration(twoDArray);
				}

			}
		});

		beginAutoGenerationButton.setOnAction(new EventHandler<ActionEvent>() {
			public void handle(ActionEvent t) {

				try {
					AutoGeneration.multipleOfShapePointCounter = Integer.parseInt(multipleOfCounterInput.getText());

					// disables everything
					beginAutoGenerationButton.setDisable(true);
					stepButton.setDisable(true);
					lockInValuesButton.setDisable(true);

					AutoGeneration.paused = false;
					AutoGeneration.beginAutoGeneration(twoDArray);

				} catch (NumberFormatException e) {
					multipleOfCounterInput.setText("Bad input");
				}

			}
		});

		pauseAutoGenerationButton.setOnAction(new EventHandler<ActionEvent>() {
			public void handle(ActionEvent t) {

				// System.out.println("Pause button fired");

				beginAutoGenerationButton.setDisable(false);
				stepButton.setDisable(false);


			}
		});

		resetButton.setOnAction(new EventHandler<ActionEvent>() {
			public void handle(ActionEvent t) {

				// reset buttons
				beginAutoGenerationButton.setDisable(true);
				stepButton.setDisable(true);

				// if a valid file path exists, then the auto-lock button is
				// enabled, otherwise not
				if (AutoGeneration.autoGenerationSavePath == null) {
					lockInValuesButton.setDisable(true);
				} else {
					lockInValuesButton.setDisable(false);
				}

				// resets lots of panes and variables
				reset();

			}
		});

		solveButton.setOnAction(new EventHandler<ActionEvent>() {
			public void handle(ActionEvent t) {

				// Only draw lines if all the rows, columns, and
				// big boxes add up to N.
				if (addUpAllRows() & addUpAllColumns() & addUpAllBigBoxes()) {

					boolean freeVariablesPresent;

					freeVariablesPresent = drawLines();

					// displays the equations and their solutions on the primaryStage
					Equation.display(equationList, freeVariablesPresent);

					// resized primaryStage to fit equations and their solutions
					primaryStage.sizeToScene();

					if(!freeVariablesPresent){
						System.out.println("No free variables.");
					}
					else{
						System.out.println("Free variables present.");
					}

				} else {
					equationBox.getChildren().add(new Text("ERROR: All boxes must be green to solve equations."));
					equationBox.getChildren().add(new Text(System.getProperty("line.separator")));
					primaryStage.sizeToScene();
				}

			}
		});

		autoGenerationBox.setMinWidth(N * 2 * BOX_HEIGHT);
		autoGenerationBox.getChildren().add(new Text("MATRIX AUTO-GENERATION"));
		autoGenerationBox.getChildren().add(new Text(""));
		autoGenerationBox.getChildren().add(setSaveDirectoryButton);
		autoGenerationBox.getChildren().add(new Text(""));
		autoGenerationBox.getChildren().add(openFileButton);
		autoGenerationBox.getChildren().add(new Text(""));
		autoGenerationBox.getChildren().add(lockInValuesButton);
		autoGenerationBox.getChildren().add(new Text(""));
		autoGenerationBox.getChildren().add(stepButton);
		autoGenerationBox.getChildren().add(new Text(""));
		autoGenerationBox.getChildren().add(beginAutoGenerationButton);
		// autoGenerationBox.getChildren().add(new Text(""));
		// autoGenerationBox.getChildren().add(pauseAutoGenerationButton);
		autoGenerationBox.getChildren().add(new Text(""));
		autoGenerationBox.getChildren().add(textFieldExplanation);
		autoGenerationBox.getChildren().add(multipleOfCounterInput);
		autoGenerationBox.getChildren().add(new Text(""));
		autoGenerationBox.getChildren().add(onePerFamilyCheckBox);
		autoGenerationBox.getChildren().add(new Text(""));
		autoGenerationBox.getChildren().add(pointsChecked);
		autoGenerationBox.getChildren().add(new Text(""));
		autoGenerationBox.getChildren().add(pointsFound);
		autoGenerationBox.getChildren().add(new Text(""));
		autoGenerationBox.getChildren().add(verticesFound);
		autoGenerationBox.getChildren().add(new Text(""));
		//autoGenerationBox.getChildren().add(resetButton);
		//autoGenerationBox.getChildren().add(new Text(""));

		//autoGenerationBox.setPrefWidth(250);

		bottomPane.setAlignment(javafx.geometry.Pos.BASELINE_LEFT);
		bottomPane.setPadding(new Insets(10, 10, 10, 10));
		bottomPane.setSpacing(5);
		bottomPane.getChildren().add(new Text("                                                                  "));
		bottomPane.getChildren().add(openButton);
		bottomPane.getChildren().add(solveButton);
		bottomPane.getChildren().add(saveButton);
		bottomPane.getChildren().add(resetButton);

		scrollPane.setHbarPolicy(ScrollPane.ScrollBarPolicy.AS_NEEDED);
		scrollPane.setVbarPolicy(ScrollPane.ScrollBarPolicy.AS_NEEDED);
		scrollPane.setStyle("-fx-background-color:transparent;"); // get rid of scrollpane border
		scrollPane.setContent(centerPane);

		// add panes to a masterPane, which is of type BorderPane
		masterPane.setCenter(scrollPane);
		masterPane.setRight(equationBox);
		masterPane.setLeft(autoGenerationBox);
		masterPane.setBottom(bottomPane);

		Scene mainScene = new Scene(masterPane);
		mainScene.setOnKeyReleased(e -> KeyReleased(e));

		primaryStage.setScene(mainScene);
		primaryStage.show();

	}

	private static void KeyReleased(KeyEvent e) {

		// if L key was pressed, then draw lines
		if (e.getCode().toString() == "L") {
			// only draw lines if all the rows, columns, and big boxes add up to
			// N
			if (addUpAllRows() & addUpAllColumns() & addUpAllBigBoxes()) {

				boolean freeVariablesPresent;

				freeVariablesPresent = drawLines();

				// displays the equations and their solutions on the primaryStage
				Equation.display(equationList, freeVariablesPresent);

				// resized primaryStage to fit equations and their solutions
				primaryStage.sizeToScene();

				if(!freeVariablesPresent){
					System.out.println("No free variables.");
				}
				else{
					System.out.println("Free variables present.");
				}

			} else {
				equationBox.getChildren().add(new Text("ERROR: All boxes must be green to solve equations."));
				equationBox.getChildren().add(new Text(System.getProperty("line.separator")));
				primaryStage.sizeToScene();
			}
		}
		// if S key was pressed, then save matrix
		else if (e.getCode().toString() == "S") {
			OpenSave.saveMatrixByUser();
		}
		// if O key was pressed, then open matrix
		else if (e.getCode().toString() == "O") {
			OpenSave.openMatrixByUser();
		}
		// if C key was pressed, then reset just the equations to resolve this
		// or different matrix
		// matrix
		else if (e.getCode().toString() == "C") {
			resetEquations();
		} else if (e.getCode().toString() == "X") {
			AutoGeneration.paused = true;
		}

	}

	// resets the grid and equations for a new matrix
	private static void reset() {

		// NOTE: The reset is split into resetting the visible aspects of the
		// grid and the invisible aspects. This is in preparation for
		// auto-generation functionality, to be developed later

		// NOTE: The reset can also be accomplished by having a "resetVisible()"
		// and "resetInvisible()" methods within the CustomBox class; the choice
		// of implementation seems arbitrary at this point

		resetTwoDArray();
		resetEquations();
		resetGrid();
		AutoGeneration.reset();
		primaryStage.sizeToScene();

		screenLocked = false;

		// clear all items from memory of autogenerated vertices
		AutoGeneration.memory.clear();

	}

	// resets equation solutions and list of equations, but not immutable
	// property
	public static void resetEquations() {

		// this for-loop resets all aspects of the matrix custom boxes except
		// the value
		for (int i = 0; i < twoDArray.length; i++) {

			for (int j = 0; j < twoDArray[i].length; j++) {
				// twoDArray[i][j].setValue(0);
				twoDArray[i][j].letter = " ";
				twoDArray[i][j].partOfLine = false;

			}
		}


		// clears the arraylist that holds the system of equations
		resetEquationList();

		// deletes all lines from the grid, so as to clear the letter-connecting
		// lines
		clearLines();

		// reset letters
		resetLetters();

		// clears the pane that displays equations and solutions
		equationBox.getChildren().clear();


	}

	// resets equationList arraylist
	private static void resetEquationList() {

		// clears each of the treemaps that represents an equation, in case it
		// helps with memory management
		for (int i = 0; i < equationList.size(); i++) {
			equationList.get(i).reset();
		}

		// this one line might be enough without the above for-loop
		equationList.clear();

	}

	// resets twoDArray values and immutable properties
	private static void resetTwoDArray() {

		for (int i = 0; i < twoDArray.length; i++) {

			for (int j = 0; j < twoDArray[i].length; j++) {
				twoDArray[i][j].setValue(0);
				twoDArray[i][j].immutable = false;
				// twoDArray[i][j].letter = " ";
				// twoDArray[i][j].partOfLine = false;
				// twoDArray[i][j].immutable = false;

			}
		}

	}

	// this method resets and makes invisible the little letters and their boxes
	// in the upper right of each small block, in preparation for another matrix
	public static void resetLetters() {

		// resets values inside of grid boxes
		for (int i = 0; i < twoDArray.length; i++) {

			for (int j = 0; j < twoDArray[i].length; j++) {

				// make the little letter box in the upper right invisible
				twoDArray[i][j].letterBox.setStroke(Color.TRANSPARENT);
				twoDArray[i][j].letterBox.setFill(Color.TRANSPARENT);

				// set the letter in the letter box to invisible and to nothing
				twoDArray[i][j].letterText.setFill(Color.TRANSPARENT);
				twoDArray[i][j].letterText.setStroke(Color.BLACK);
				twoDArray[i][j].letterText.setText(" ");

			}
		}
	}

	// resets the grid that is visible to the user on the screen
	private static void resetGrid() {

		// resets values inside of grid boxes
		for (int i = 0; i < twoDArray.length; i++) {

			for (int j = 0; j < twoDArray[i].length; j++) {

				// set value in each box to the value that is in the matrix
				twoDArray[i][j].text.setText(Integer.toString(twoDArray[i][j].getValue()));
				twoDArray[i][j].text.setFill(Color.TRANSPARENT);

				twoDArray[i][j].outline.setFill(Color.TRANSPARENT);

			}
		}

		// remove the bottom right "0"
		twoDArray[N * N][N * N].text.setStroke(Color.TRANSPARENT);

	}

	// Draws multicolored equation lines. Returns true if system of equations contains
	// a free variable and returns false if system of equations does not contain a
	// free variable.
	public static boolean drawLines() {

		// System.out.println("In drawLines");

		// holds value of current line color
		Color currentLineColor;

		// holds the two letters that are being alternated during line drawing
		String[] pairOfLetters;

		// initialize the start point
		CustomBox startingPoint = null;

		// Stack of CustomBox arrays representing the
		// start and end-points that need to be connected.
		Stack<CustomBox> stackOfStartingPoints = new Stack<>();

		// constant
		final char[] poolOfCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".toCharArray();

		// position of the next letter pair to be retrieved
		int letterPairPosition = 0;

		// the complementary value is equal to N minus value at the current box
		// (N - current value)
		int complementaryValue;

		// the complementary value of a value is N minus that value
		String complementaryLetter;

		// Keeps track if current line has reached terminal point. If it has, it
		// might still have previous points to draw lines from, so the line
		// series is not over until the stack is also empty. Once the stack is
		// empty and a
		// terminal point has been reached, then a new line can be started.
		boolean haveReachedTerminalPoint = false;

		// is set to true when no more lines can be drawn
		boolean allLinesFinished = false;

		// keep drawing lines until there are enough letters
		while (letterPairPosition < poolOfCharacters.length - 1 && !allLinesFinished) {

			// System.out.println("In outer while loop");

			// every new line is drawn with a new random color
			currentLineColor = randomColor();

			pairOfLetters = getNewLetterPair(letterPairPosition, poolOfCharacters);

			// letterPairPosition is incremented by 2 for the next letter pair
			letterPairPosition = letterPairPosition + 2;

			// set starting point to null when starting to search for an initial
			// point to a new line
			startingPoint = null;

			haveReachedTerminalPoint = false;

			// both of these have to be true for the line series to have nowhere
			// to go
			while (!haveReachedTerminalPoint || !stackOfStartingPoints.empty()) {

				// System.out.println("In inner while loop");

				if (!stackOfStartingPoints.empty()) {
					startingPoint = stackOfStartingPoints.pop();
				}

				// if we are trying to start a brand new line, then we need to
				// find a valid starting point for it
				if (startingPoint == null) {
					startingPoint = findNewStartingPoint();

					// if starting point is still null, then no new starting
					// point
					// can be found, and no more new lines can be drawn and the
					// line
					// drawing portion of the program is finished
					if (startingPoint == null) {
						allLinesFinished = true;
						break;
					} else {

						// place a variable letter into the upper box of the
						// starting point in a visual way
						twoDArray[startingPoint.row][startingPoint.column].letterText.setText(pairOfLetters[0]);
						twoDArray[startingPoint.row][startingPoint.column].letterBox.setFill(currentLineColor);

						// and then in a non-visual, behind-the-scenes way for
						// future auto-processing
						twoDArray[startingPoint.row][startingPoint.column].letter = pairOfLetters[0];
						twoDArray[startingPoint.row][startingPoint.column].partOfLine = true;
					}
				}

				// Set complementary value.
				complementaryValue = N - startingPoint.getValue();

				// Set complementary letter.
				// If the current starting point holds a variable equal to the
				// first letter of the letter pair, then the complementaryLetter
				// is the second letter of the pair, and vice versa
				if (startingPoint.letterText.getText().equals(pairOfLetters[0])) {
					complementaryLetter = pairOfLetters[1];
				} else {
					complementaryLetter = pairOfLetters[0];
				}

				// look for a complementary value within the same row
				CustomBox rowPoint = checkRow(startingPoint.row, startingPoint.column, complementaryValue);

				if (rowPoint != null) {

					// draw line between starting point and this
					// point
					drawLine(startingPoint, rowPoint, currentLineColor);

					// place a variable letter into the upper box of the
					// ending point in a visual way
					twoDArray[rowPoint.row][rowPoint.column].letterText.setText(complementaryLetter);
					twoDArray[rowPoint.row][rowPoint.column].letterBox.setFill(currentLineColor);

					// and then in a non-visual, behind-the-scenes way for
					// future auto-processing
					twoDArray[rowPoint.row][rowPoint.column].letter = complementaryLetter;
					twoDArray[rowPoint.row][rowPoint.column].partOfLine = true;

					// push this ending point onto the stack as a
					// new starting point to evaluate later
					stackOfStartingPoints.push(rowPoint);
				}

				// look for a complementary value within the same column
				CustomBox columnPoint = checkColumn(startingPoint.row, startingPoint.column, complementaryValue);

				if (columnPoint != null) {

					// draw line between starting point and this
					// point
					drawLine(startingPoint, columnPoint, currentLineColor);

					// place a variable letter into the upper box of the
					// ending point in a visual way
					twoDArray[columnPoint.row][columnPoint.column].letterText.setText(complementaryLetter);
					twoDArray[columnPoint.row][columnPoint.column].letterBox.setFill(currentLineColor);

					// and then in a non-visual, behind-the-scenes way for
					// future auto-processing
					twoDArray[columnPoint.row][columnPoint.column].letter = complementaryLetter;
					twoDArray[columnPoint.row][columnPoint.column].partOfLine = true;

					// push this ending point onto the stack as a
					// new starting point to evaluate later
					stackOfStartingPoints.push(columnPoint);
				}

				// look for a complementary value within the same big box
				CustomBox bigBoxPoint = checkBigBox(startingPoint.row, startingPoint.column, complementaryValue);

				if (bigBoxPoint != null) {

					// draw line between starting point and this
					// point
					drawLine(startingPoint, bigBoxPoint, currentLineColor);

					// place a variable letter into the upper box of the
					// ending point in a visual way, on screen
					twoDArray[bigBoxPoint.row][bigBoxPoint.column].letterText.setText(complementaryLetter);
					twoDArray[bigBoxPoint.row][bigBoxPoint.column].letterBox.setFill(currentLineColor);

					// and then in a non-visual, behind-the-scenes way for
					// future auto-processing
					twoDArray[bigBoxPoint.row][bigBoxPoint.column].letter = complementaryLetter;
					twoDArray[bigBoxPoint.row][bigBoxPoint.column].partOfLine = true;

					// push this ending point onto the stack as a
					// new starting point to evaluate later
					stackOfStartingPoints.push(bigBoxPoint);
				}

				// if no complementary points were found, then
				// we have reached a terminal point, but there
				// might be other points yet to be added to the
				// line, if the stack is not empty
				if (rowPoint == null && columnPoint == null && bigBoxPoint == null) {
					haveReachedTerminalPoint = true;
				}

			} // single line while loop

			if (letterPairPosition >= poolOfCharacters.length - 1) {

				/**
				 * Alert alert = new Alert(AlertType.INFORMATION);
				 * alert.setTitle("Warning"); alert.setHeaderText(null);
				 * alert.setContentText(
				 * "The program has run out of variable letters to use. Program is stopping."
				 * );
				 *
				 * alert.showAndWait();
				 *
				 */

				equationBox.getChildren().add(new Text("ERROR: The program has run out of variable letters to use."));
				equationBox.getChildren().add(new Text(System.getProperty("line.separator")));
			}

		} // while loop for starting a new line

		return generateEquations();

	}

	// This function generates a system of linear equations based on the
	// input inside the JavaFX GUI entered by the user. The function returns
	// true if free variables are present in the system and false if not.
	private static boolean generateEquations() {

		generateRowEquations();
		boolean freeVariablesPresent = true;

		// if equationList is empty after row equations were generated, then no
		// letter variables have yet been generated in the grid, and we need not
		// proceed further
		if (!equationList.isEmpty()) {

			generateColumnEquations();
			generateBigBoxEquations();

			Equation.removeRedundantEquations(equationList);
			HashSet<String> setOfAllVariables = Equation.equalize(equationList);
			// solves equations without displaying them
			freeVariablesPresent = Equation.solve(equationList, setOfAllVariables);

			/*
			// displays the equations and their solutions on the primaryStage
			Equation.display(equationList);

			// resized primaryStage to fit equations and their solutions
			primaryStage.sizeToScene();
			*/
		}

		return freeVariablesPresent;
	}

	// generates equations from each row in the matrix and adds the equations to
	// the list of equations
	private static void generateRowEquations() {

		// rather than comparing i and j to the length of the array in the for
		// loop, we will use the immediate variable N squared, so as to optimize
		// for speed
		for (int i = 0; i < N * N; i++) {

			Equation eq = new Equation();

			for (int j = 0; j < N * N; j++) {

				// System.out.println("row = " + i);
				// System.out.println("column = " + j);
				// System.out.println(twoDArray[i][j].letter);

				if (!twoDArray[i][j].letter.equals(" ")) {

					String letter = twoDArray[i][j].letter;
					Integer coefficient = eq.map.get(letter);
					if (coefficient == null) {
						// New variable
						eq.map.put(letter, 1);
					} else {
						// Existing variable. Increment its coefficient.
						eq.map.put(letter, coefficient + 1);
					}

				}

			}
			// equationBox.getChildren().add(new Text(eq.map.toString()));
			equationList.add(eq);

		}

	}

	// generates equations from each column in the matrix and adds the equations
	// to the list of equations
	private static void generateColumnEquations() {

		// rather than comparing i and j to the length of the array in the for
		// loop, we will use the immediate variable N squared, so as to optimize
		// for speed

		// outside loop chooses a column
		for (int i = 0; i < N * N; i++) {

			Equation eq = new Equation();

			// inside loop goes down the column and adds value of each row in
			// that column
			for (int j = 0; j < N * N; j++) {

				if (!twoDArray[j][i].letter.equals(" ")) {

					String letter = twoDArray[j][i].letter;
					Integer coefficient = eq.map.get(letter);
					if (coefficient == null) {
						// New variable
						eq.map.put(letter, 1);
					} else {
						// Existing variable. Increment its coefficient.
						eq.map.put(letter, coefficient + 1);
					}

				}

			}

			equationList.add(eq);

		}

	}

	// generates equations from each big block in the matrix and adds the
	// equations to the list of equations
	private static void generateBigBoxEquations() {

		for (int topLeftBigBoxRow = 0; topLeftBigBoxRow < N * N; topLeftBigBoxRow = topLeftBigBoxRow + N) {

			for (int topLeftBigBoxColumn = 0; topLeftBigBoxColumn < N * N; topLeftBigBoxColumn = topLeftBigBoxColumn
					+ N) {

				Equation eq = new Equation();

				for (int i = topLeftBigBoxRow; i < topLeftBigBoxRow + N; i++) {

					for (int j = topLeftBigBoxColumn; j < topLeftBigBoxColumn + N; j++) {

						if (!twoDArray[i][j].letter.equals(" ")) {

							String letter = twoDArray[i][j].letter;
							Integer coefficient = eq.map.get(letter);
							if (coefficient == null) {
								// New variable
								eq.map.put(letter, 1);
							} else {
								// Existing variable. Increment its coefficient.
								eq.map.put(letter, coefficient + 1);
							}

						}

					}

				}

				equationList.add(eq);

			}
		}
	}

	// draws a line between two small boxes
	public static void drawLine(CustomBox startingPoint, CustomBox endingPoint, Color color) {

		// System.out.println(testCounter);
		// ++testCounter;

		Line line = new Line(startingPoint.letterText.getX(), startingPoint.letterText.getY(),
				endingPoint.letterText.getX(), endingPoint.letterText.getY());
		line.setStroke(Color.BLACK);

		centerPane.getChildren().add(line);

	}

	// finds a valid starting point for a new line. If none exist, returns null.
	public static CustomBox findNewStartingPoint() {

		for (int i = 0; i < twoDArray.length - 1; i++) {

			for (int j = 0; j < twoDArray[i].length - 1; j++) {

				// if box contains a 1 and N - 1, inclusive, and it is not
				// already
				// part of a line, then this is a valid starting point
				if (twoDArray[i][j].getValue() >= 1 && twoDArray[i][j].getValue() <= (N - 1)
						&& !twoDArray[i][j].partOfLine) {
					return twoDArray[i][j];
				}
			}
		}

		return null;
	}

	// checks the rest of the values in the row of the given CustomBox
	// to see if a complementary value (N minus current value) is found in a
	// small box that is not already part of a line series. Returns null if not
	// found.
	public static CustomBox checkRow(int row, int column, int complementaryValue) {

		// System.out.println("In checkRow");

		// check all small boxes to the right of the starting point
		for (int j = column + 1; j < twoDArray[row].length - 1; j++) {
			if (twoDArray[row][j].getValue() == complementaryValue && !twoDArray[row][j].partOfLine) {
				return twoDArray[row][j];
			}

		}

		// check all small boxes to the left of the starting point
		for (int j = column - 1; j >= 0; j--) {
			if (twoDArray[row][j].getValue() == complementaryValue && !twoDArray[row][j].partOfLine) {
				return twoDArray[row][j];
			}

		}

		return null;

	}

	// checks the rest of the values in the column of the given CustomBox
	// to see if a complementary value (N minus current value) is found in a
	// small box that is not already part of a line series. Returns null if not
	// found.
	public static CustomBox checkColumn(int row, int column, int complementaryValue) {

		// check all boxes below the starting point
		for (int j = row + 1; j < twoDArray.length - 1; j++) {

			if (twoDArray[j][column].getValue() == complementaryValue && !twoDArray[j][column].partOfLine) {
				return twoDArray[j][column];
			}
		}

		// check all boxes above the starting point
		for (int j = row - 1; j >= 0; j--) {

			if (twoDArray[j][column].getValue() == complementaryValue && !twoDArray[j][column].partOfLine) {
				return twoDArray[j][column];
			}
		}

		return null;
	}

	// Checks the rest of the values in the big box containing the parameter
	// row and column
	// to see if a complementary value (N minus current value) is found in a
	// small box that is not already part of a line series. Returns null if not
	// found.
	public static CustomBox checkBigBox(int row, int column, int complementaryValue) {

		int startRow = 0;
		int startColumn = 0;

		// find top left corner of the big box containing the row and column
		// parameters
		while ((startRow + N) <= row) {
			startRow = startRow + N;
		}
		while ((startColumn + N) <= column) {
			startColumn = startColumn + N;
		}

		/**
		 * if (startRow < 0) { startRow = 0; System.out.println(
		 * "In a part that should never be reached"); } if (startColumn < 0) {
		 * startColumn = 0; System.out.println(
		 * "In a part that should never be reached"); }
		 */

		// check the big box
		for (int topLeftBigBoxRow = startRow; topLeftBigBoxRow < startRow + N; ++topLeftBigBoxRow) {

			for (int topLeftBigBoxColumn = startColumn; topLeftBigBoxColumn < startColumn + N; ++topLeftBigBoxColumn) {

				if (twoDArray[topLeftBigBoxRow][topLeftBigBoxColumn].getValue() == complementaryValue
						&& !twoDArray[topLeftBigBoxRow][topLeftBigBoxColumn].partOfLine) {
					return twoDArray[topLeftBigBoxRow][topLeftBigBoxColumn];
				}

			}
		}

		return null;
	}

	public static String[] getNewLetterPair(int position, char[] poolOfCharacters) {

		// System.out.println("In getNewLetterPair");

		String[] temp = new String[2];

		temp[0] = Character.toString(poolOfCharacters[position]);
		temp[1] = Character.toString(poolOfCharacters[position + 1]);

		return temp;

	}

	// returns a random color
	public static Color randomColor() {
		return new Color(Math.random(), Math.random(), Math.random(), Math.random());
	}

	// prompts user for an N value and sets N equal to that integer
	private static void obtainNValueFromUser() {

		Stage initialStage = new Stage();
		TextField field = new TextField("3");
		Label label = new Label("Enter N:");
		Button submitButton = new Button("Submit");
		Button exitButton = new Button("Exit Program");

		VBox firstScreen = new VBox();
		firstScreen.setPadding(new Insets(10, 10, 10, 10));
		firstScreen.setSpacing(10);

		// field.setOnKeyReleased(e -> enterKeyReleased());

		firstScreen.getChildren().addAll(label, field, submitButton, exitButton);

		// when the Submit button is clicked, N is processed and initial stage
		// closes if N is an integer
		submitButton.setOnAction(new EventHandler<ActionEvent>() {
			public void handle(ActionEvent t) {

				try {
					N = Integer.parseInt(field.getText());
					initialStage.close();
					// break;
				} catch (NumberFormatException e) {
					field.setText("Bad input, try again");
				}

			}
		});

		// when the Enter key is pressed in the text box, N is processed and
		// initial stage closes if N is an integer
		field.setOnKeyReleased(new EventHandler<KeyEvent>() {
			public void handle(KeyEvent t) {

				if (t.getCode() == KeyCode.ENTER) {

					try {
						N = java.lang.Integer.parseInt(field.getText());
						initialStage.close();
						// break;
					} catch (NumberFormatException e) {
						field.setText("Bad input, try again");
					}

				}
			}
		});

		// when the Exit button is clicked, the program closes
		exitButton.setOnAction(new EventHandler<ActionEvent>() {
			public void handle(ActionEvent t) {
				System.exit(0);
			}
		});

		initialStage.setScene(new Scene(firstScreen));

		initialStage.showAndWait();

	}

	// initializes matrix and displays the grid in the center pane
	private static void initializeMatrixAndGrid() {

		// initialize matrix values and display the matrix
		for (int i = 0; i < twoDArray.length; i++) {
			// draw thick vertical lines to separate big boxes from little boxes
			if (i % N == 0) {

				Line thickVerticalLine = new Line(i * BOX_HEIGHT, 0, i * BOX_HEIGHT, (BOX_HEIGHT * N * N));
				thickVerticalLine.setStrokeWidth(2);
				centerPane.getChildren().add(thickVerticalLine);
			}

			for (int j = 0; j < twoDArray[i].length; j++) {

				CustomBox box = new CustomBox(BOX_HEIGHT * j, BOX_HEIGHT * i);

				twoDArray[i][j] = box;
				twoDArray[i][j].row = i;
				twoDArray[i][j].column = j;

				// remove outline from bottom row and right-most column
				if ((j == (twoDArray[i].length - 1)) || (i == (twoDArray.length - 1))) {
					twoDArray[i][j].outline.setStroke(Color.TRANSPARENT);
				}

				// add the visual nodes of CustomBox to the grid
				centerPane.getChildren().add(twoDArray[i][j].outline);
				centerPane.getChildren().add(twoDArray[i][j].text);
				centerPane.getChildren().add(twoDArray[i][j].letterBox);
				centerPane.getChildren().add(twoDArray[i][j].letterText);

				// draw thick horizontal lines to separate big boxes from little
				// boxes
				// the lines are drawn only when drawing the last column of the
				// grid
				if ((i == twoDArray.length - 1) && (j % N == 0)) {
					Line thickHorizontalLine = new Line(0, j * BOX_HEIGHT, (BOX_HEIGHT * N * N), j * BOX_HEIGHT);
					thickHorizontalLine.setStrokeWidth(2);
					centerPane.getChildren().add(thickHorizontalLine);
				}

			}

		}

		// remove the bottom right "0"
		twoDArray[N * N][N * N].text.setStroke(Color.TRANSPARENT);

	}

	// removes all lines from the centerPane
	private static void clearLines() {

		// this line is created simply to extract its ".getClass()" return so as
		// to compare it to nodes in the centerPane and figure out which nodes
		// are lines and which are not
		Line dummyLine = new Line();

		// java does not allow nodes to be removed from collection while
		// iterating through the collection, so in the below for-loop, all lines
		// are stored into an arraylist, which is then used to remove the lines
		// from centerPane
		ArrayList<Node> nodesToBeDeleted = new ArrayList<Node>();

		for (Node node : centerPane.getChildren()) {

			if (node.getClass() == dummyLine.getClass()) {

				nodesToBeDeleted.add(node);

			}

		}

		// testCounter = 0;

		// System.out.println("In clear lines");

		for (int i = 0; i < nodesToBeDeleted.size(); i++) {
			centerPane.getChildren().remove(nodesToBeDeleted.get(i));
			// ++testCounter;
			// System.out.println(testCounter);
		}

		// adds thick lines to centerPane so as to divide up the grid into NxN
		// big boxes, making the grid easy to visualize at a glance
		addThickLines();

	}

	// adds thick lines to centerPane so as to divide up the grid into NxN big
	// boxes, making the grid easy to visualize at a glance
	private static void addThickLines() {

		for (int i = 0; i < twoDArray.length; i++) {
			// draw thick vertical lines to separate big boxes from little boxes
			if (i % N == 0) {

				Line thickVerticalLine = new Line(i * BOX_HEIGHT, 0, i * BOX_HEIGHT, (BOX_HEIGHT * N * N));
				thickVerticalLine.setStrokeWidth(2);
				centerPane.getChildren().add(thickVerticalLine);
			}

			for (int j = 0; j < twoDArray[i].length; j++) {

				// draw thick horizontal lines to separate big boxes from little
				// boxes the lines are drawn only when drawing the last column
				// of the grid
				if ((i == twoDArray.length - 1) && (j % N == 0)) {
					Line thickHorizontalLine = new Line(0, j * BOX_HEIGHT, (BOX_HEIGHT * N * N), j * BOX_HEIGHT);
					thickHorizontalLine.setStrokeWidth(2);
					centerPane.getChildren().add(thickHorizontalLine);
				}

			}

		}
	}

	// adds up all values in a given row, changes summation box to green if sum
	// = N, and returns sum
	public static int addUpRow(int row) {

		int rowSum = 0;

		for (int column = 0; column < N * N; column++) {

			rowSum = rowSum + twoDArray[row][column].getValue();

		}

		// this changes the summation box to the appropriate color
		twoDArray[row][N * N].setValue(rowSum);

		return rowSum;

	}

	// This function adds up the values in rows until it finds a row that does
	// not add up to N, turns the summation box
	// at the right-most column green if the row adds up to N, and returns true
	// if all rows add up to N.
	public static boolean addUpAllRows() {

		for (int row = 0; row < N * N; row++) {

			if (addUpRow(row) != N) {
				return false;
			}

		}

		return true;
	}

	public static int addUpColumn(int column) {

		int columnSum = 0;

		for (int row = 0; row < N * N; row++) {

			columnSum = columnSum + twoDArray[row][column].getValue();

		}

		// this changes the summation box to the appropriate color
		twoDArray[N * N][column].setValue(columnSum);

		return columnSum;

	}

	// This function adds up the values in the columns until it finds a column
	// that does not add up to N, turns the summation box
	// at the bottom-most row green if the column adds up to N, and returns true
	// if all columns add up to N.
	public static boolean addUpAllColumns() {

		for (int column = 0; column < N * N; column++) {

			if (addUpColumn(column) != N) {
				return false;
			}

		}

		return true;
	}

	// This function adds up the values in every big box, turns the all small
	// boxes in the big box green if the small boxes add up to N, and returns
	// true if all the big boxes add up to N. It does not return until it
	// traverses every big box.
	public static boolean addUpAllBigBoxes() {

		for (int topLeftBigBoxRow = 0; topLeftBigBoxRow < N * N; topLeftBigBoxRow = topLeftBigBoxRow + N) {

			for (int topLeftBigBoxColumn = 0; topLeftBigBoxColumn < N * N; topLeftBigBoxColumn = topLeftBigBoxColumn
					+ N) {

				if (addUpBigBox(topLeftBigBoxRow, topLeftBigBoxColumn, true) != N) {
					return false;
				}

			}
		}

		return true;
	}

	// Sums up all values in a big box, changes its color to green if sum is N,
	// and returns the sum.
	// The ready variable is true if the top left row and top left column passed
	// in represent the top left row and column.
	// The ready variable is false if those variables represent some arbitrary
	// row and column within the big box.
	public static int addUpBigBox(int topLeftBigBoxRow, int topLeftBigBoxColumn, boolean ready) {

		int bigBoxSum = 0;

		int startRow = 0;
		int startColumn = 0;

		// find top left corner of the big box containing the row and column
		// parameters
		while ((startRow + N) <= topLeftBigBoxRow) {
			startRow = startRow + N;
		}
		while ((startColumn + N) <= topLeftBigBoxColumn) {
			startColumn = startColumn + N;
		}

		topLeftBigBoxRow = startRow;
		topLeftBigBoxColumn = startColumn;

		// get sum of big box
		for (int row = topLeftBigBoxRow; row < topLeftBigBoxRow + N; row++) {

			for (int column = topLeftBigBoxColumn; column < topLeftBigBoxColumn + N; column++) {

				bigBoxSum = bigBoxSum + twoDArray[row][column].getValue();

			}

		}

		// if the sum = N, then set its color to green
		if (bigBoxSum == N) {

			changeBigBoxColor(topLeftBigBoxRow, topLeftBigBoxColumn, Color.GREEN);

		}
		// if sum is not N, then set its color to transparent
		else {

			changeBigBoxColor(topLeftBigBoxRow, topLeftBigBoxColumn, Color.TRANSPARENT);
		}

		return bigBoxSum;

	}

	public static void changeBigBoxColor(int topLeftBigBoxRow, int topLeftBigBoxColumn, Color color) {

		for (int row = topLeftBigBoxRow; row < topLeftBigBoxRow + N; row++) {

			for (int column = topLeftBigBoxColumn; column < topLeftBigBoxColumn + N; column++) {

				// Do not change fill color of immutable boxes during
				// auto-generation. They should remain pink.
				if (!twoDArray[row][column].immutable) {
					twoDArray[row][column].outline.setFill(color);
				} else {
					twoDArray[row][column].outline.setFill(Color.RED);
				}
			}

		}
	}

	public static void main(String[] args) {

		launch(args);

	}

}
