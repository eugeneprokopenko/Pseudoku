import java.io.File;

import javafx.scene.paint.Color;
import javafx.scene.text.Text;
import java.util.*;

/**
 * This class manages auto generation of matrices.
 *
 * @author Eugene Prokopenko
 */
public class AutoGeneration {

	private static final int N = Pseudoku.N;

	// A "shape point" is a matrix configuration where all of the matrix's
	// columns, rows, big boxes add up to N.
	public static int numberOfShapePointsChecked = 0;
	public static int numberOfShapePointsFound = 0;
	public static int numberOfVerticesFound = 0;

	// This variable is specified by the user. The auto-generation pauses every time numberOfShapePointsChecked hits a multiple of this value
	public static int multipleOfShapePointCounter = 0;

	// this counter resets every time it hits a multiple of the numberOfShapePointsChecked variable, where the multiple is specified by the user
	// public static int tempShapePointCounter = 0;

	// Stack of GridPoints representing the small boxes in the matrix that need
	// to be tried, as well as values for those points that need to be tried.
	private static Stack<GridPoint> stackOfGridPoints = new Stack<>();

	// True when the auto-generation is paused by the user
	public static boolean paused = false;

	// True when the auto-generation is completed
	public static boolean done = false;

	// Current point under consideration. It is initialized to position 0, -1,
	// 0, because this is the hypothetical position before the first position
	private static GridPoint currentPoint = new GridPoint(0, -1, 0);

	// path where autogenerated matrices are saved
	public static File autoGenerationSavePath = null;
	// public static File autoGenerationSavePath = new File("/Users/eugeneprokopenko/Desktop/Pseudoku matrices");

	// "memory" is a LinkedList of previously generated sets of equations.
	// Each set is saved only once. It is used to check whether a given vertex's family has been
	// previously found by the AutoGeneration algorithm.
	public static LinkedList<ArrayList<Equation>> memory = new LinkedList<ArrayList<Equation>>();

	/**
	 * Resets and clears all fields within the AutoGeneration class.
	 */
	public static void reset(){

		// reset matrix counter variables
		numberOfShapePointsChecked = 0;
		numberOfShapePointsFound = 0;
		numberOfVerticesFound = 0;

		// resets textboxes with counters
		Pseudoku.pointsChecked.setText("Matrices Checked: " + numberOfShapePointsChecked);
		Pseudoku.pointsFound.setText("Points Found: " + numberOfShapePointsFound);
		Pseudoku.verticesFound.setText("Vertices Found: " + numberOfVerticesFound);

		stackOfGridPoints.clear();

		paused = false;

		done = false;

		currentPoint = new GridPoint(0, -1, 0);

	}

	/**
	 * Calls the setImmutability method to lock in certain boxes as
	 * unchangeable by the AutoGeneration algorithm.
	 *
	 * @param twoDArray the matrix of CustomBoxes where values should be locked.
	 */
	public static void lockInValues(CustomBox[][] twoDArray) {

		// Sets immutability by indicating which box's values have been
		// specified by the user, directly or indirectly
		setImmutability(twoDArray);
	}

	/**
	 * Auto generates matrices until a certain number have been generated
	 * or no more matrices can be generated.
	 *
	 * @param twoDArray the matrix of CustomBoxes from which to
	 * generate more matrices.
	 */
	public static void continueAutoGeneration(CustomBox[][] twoDArray) {

		/**
		 * The following is a rough outline of steps to the auto-generation
		 * algorithm. NOTE: the word "point" means "small box".
		 *
		 * STEP 1. Find next available non-immutable / non-blocked point.
		 * Non-immutable means that it was specified by the user, directly or
		 * indirectly. Non-blocked means that previous values set by the
		 * algorithm have not forced a point to be zero, e.g., it's in a row
		 * where the reset of the values add up to N.
		 *
		 * *****STEP 1(a). If such a point is found, then push all of its
		 * potential values, in GridPoint format, onto the stack. The pushing is
		 * done in ascending order. Pop the stack and set the current point to
		 * the popped point.
		 *
		 * *****STEP 1(b). If such a point is not found, then check if stack is
		 * empty.
		 *
		 * ***********STEP 1(b)(i). If stack is not empty, pop the stack and set
		 * the current point to the popped point.
		 *
		 * ***********STEP 1(b)(ii). If stack is empty, the auto-generation is
		 * finished.
		 *
		 * STEP 2. Evaluate the current point for legality. This is done by
		 * making sure that the row, column, and big box containing the point do
		 * not add up to more than N.
		 *
		 * *****STEP 2(a). If the point is illegal, check whether the stack is
		 * empty. If stack is empty, then auto-generation is over. If stack is
		 * not empty, keep popping points from the stack, and checking them for
		 * legality until either the point is legal or the stack is empty.
		 *
		 * *****STEP 2(b). If the point is legal, check whether this matrix
		 * configuration constitutes a valid "shape point." A shape point is a
		 * matrix configuration where all of the matrix's columns, rows, big
		 * boxes add up to N.
		 *
		 ************ STEP 2(b)(i). If the matrix configuration is in a shape point, then
		 * save the point as a text file in the directory specified by the user
		 * prior to commencement of the auto-generation.
		 *
		 * STEP 3. Go to STEP 1 and repeat.
		 */

		if (!done) {

			// STEP 1

			// sets currentPoint to the next available non-immutable /
			// non-blocked point.
			currentPoint = getNextPoint(twoDArray, currentPoint);

			// if currentPoint's row is negative, then a non-immutable,
			// non-blocked point was not found
			if (currentPoint.row == -1) {

				// if stack is not empty, pop its point as the next currentPoint
				if (!stackOfGridPoints.isEmpty()) {
					currentPoint = stackOfGridPoints.pop();
					// System.out.println(
					//		"Poppped: " + currentPoint.row + ", " + currentPoint.column + ", " + currentPoint.value);
				}
				// if the stack is empty, the auto-generation is finished
				else {
					done = true;

					Pseudoku.equationBox.getChildren().add(new Text(System.getProperty("line.separator")));
					Pseudoku.equationBox.getChildren().add(new Text("AUTO-GENERATION IS FINISHED"));
					Pseudoku.equationBox.getChildren().add(new Text(System.getProperty("line.separator")));
					Pseudoku.primaryStage.sizeToScene();

					return;
				}
			}
			// if a non-immutable, non-blocked point was found, then push all of
			// its potential values onto the stack in ascending order
			else {
				int ascendingCounter = 0;

				while (ascendingCounter < N) {

					stackOfGridPoints.push(new GridPoint(currentPoint.row, currentPoint.column, ascendingCounter));

					// System.out.println("");
					// System.out.println(
					//		"Pushed: " + currentPoint.row + ", " + currentPoint.column + ", " + ascendingCounter);
					// System.out.println("");

					++ascendingCounter;
				}

				// after pushing all of a point's potential point's values onto
				// the stack, set currentPoint to the most recently pushed value
				currentPoint = stackOfGridPoints.pop();
				// System.out.println(
				//		"Poppped: " + currentPoint.row + ", " + currentPoint.column + ", " + currentPoint.value);

			}

			// STEP 2

			while (true) {
				// if a legal point is found, then set the matrix value at this
				// point to this point's value and check whether the current
				// matrix configuration constitutes a "shape point". If it does,
				// then save the matrix to the directory specified by the user.
				if (legal(currentPoint)) {

					++numberOfShapePointsChecked;

					// System.out.println("numberOfShapePointsChecked = " + numberOfShapePointsChecked);
					// System.out.println("multipleOfShapePointCounter = " + multipleOfShapePointCounter);

					// pauses the auto-generation before the next iteration if the number of shape points checked has reached a multiple of a value specified by user
					if(numberOfShapePointsChecked % multipleOfShapePointCounter == 0){
						pauseAutoGeneration();

					}


					// set the matrix value at this point to this point's value
					Pseudoku.twoDArray[currentPoint.row][currentPoint.column].setValue(currentPoint.value);

					boolean allRowsEqualN = Pseudoku.addUpAllRows();
					boolean allColumnsEqualN = Pseudoku.addUpAllColumns();
					boolean allBigBoxesEqualN = Pseudoku.addUpAllBigBoxes();

					// The below if statement is true if all the boxes are green
					// or
					// pink, meaning a shape point has been found
					if (allRowsEqualN && allColumnsEqualN && allBigBoxesEqualN) {

						// increment the number of shape points found and
						// display the count for the user
						++numberOfShapePointsFound;
						Pseudoku.pointsFound.setText("Points Found: " + numberOfShapePointsFound);

						// solve the equations
						boolean freeVariablesPresent = Pseudoku.drawLines();

						if(!freeVariablesPresent){

							// VERTEX FOUND!!!!!!
							// But before saving we need to check whether the user wants to save one
							// vertex per family, and if so, we need to check whether a vertex from this family
							// has already been saved.


							if(Pseudoku.onePerFamilyCheckBox.isSelected()){

								if(!familyAlreadyRepresented(memory, Pseudoku.equationList)){

									++numberOfVerticesFound;
									Pseudoku.verticesFound.setText("Vertices Found: " + numberOfVerticesFound);

									// save the matrix representing a vertex
									OpenSave.saveMatrix(new File(
											autoGenerationSavePath.getAbsolutePath() + "//" + numberOfVerticesFound + ".txt"));

									// add set of equations (equationList) to the linked list memory of previously saved sets of equations
									ArrayList<Equation> temp = copyEquationList(Pseudoku.equationList);
									memory.add(temp);

									// DEBUG: print memory linked list
									//printMemory(memory);

								}

							} else { // all vertices will be saved



								++numberOfVerticesFound;
								Pseudoku.verticesFound.setText("Vertices Found: " + numberOfVerticesFound);

								// save the matrix representing a vertex
								OpenSave.saveMatrix(new File(autoGenerationSavePath.getAbsolutePath() + "//"
										+ numberOfVerticesFound + ".txt"));

								// If user is saving only one vertex per family,
								// then
								// add set of equations (equationList) to the
								// linked list memory of previously saved sets
								// of equations.
								// if(!familyAlreadyRepresented(memory,
								// Pseudoku.equationList)){
								// memory.add(Pseudoku.equationList);
								// }

							}

						}

						// reset the equations for solving the next matrix, if
						// needed
						Pseudoku.resetEquations();

					}

					// Only display the number of points checked if it is a
					// multiple of a certain value. Otherwise, the number would
					// be incrementing to quickly to be readable.
					// if (numberOfShapePointsChecked % 1 == 0) {
						Pseudoku.pointsChecked.setText("Matrices Checked: " + numberOfShapePointsChecked);
					// }

					// because a valid point was found, break out of the while
					// loop
					break;
				}
				// if not legal, check whether the stack is empty
				else {
					// if stack is not empty, pop its point and set it as the
					// currentPoint
					if (!stackOfGridPoints.isEmpty()) {
						currentPoint = stackOfGridPoints.pop();
						//System.out.println("Poppped: " + currentPoint.row + ", " + currentPoint.column + ", "
						//		+ currentPoint.value);
					}
					// if the stack is empty, the auto-generation is finished
					else {
						done = true;

						Pseudoku.equationBox.getChildren().add(new Text(System.getProperty("line.separator")));
						Pseudoku.equationBox.getChildren().add(new Text("AUTO-GENERATION IS FINISHED"));
						Pseudoku.equationBox.getChildren().add(new Text(System.getProperty("line.separator")));
						Pseudoku.primaryStage.sizeToScene();

						return;
					}
				}
			} // end bracket of the while loop

			// fills the current small box being considered with orange color
			placeOrangeFillOnCurrentPoint();


		} // ending bracket of "if (!done)" conditional

	}

	/**
	 * Makes a copy of an array list.
	 *
	 * @temp equationList array list to copy
	 * @return temp a copy of the array list to copy
	 */
	public static ArrayList<Equation> copyEquationList(ArrayList<Equation> equationList){

		ArrayList<Equation> temp = new ArrayList<>();

		for(int equation_number = 0; equation_number < equationList.size(); equation_number++){

			Equation eq = new Equation();
			eq.map = (TreeMap) equationList.get(equation_number).map.clone();
			temp.add(eq);

		}

		return temp;

	}


	/**
	 * Prints a linked list of systems of equations to the console. For debugging.
	 *
	 * @param memory linked list to print.
	 */
	public static void printMemory(LinkedList<ArrayList<Equation>> memory){

		System.out.println("memory size: " + memory.size());

		for (int memory_index = 0; memory_index < memory.size(); memory_index++) {

				System.out.println("");

				for (int i = 0; i < memory.get(memory_index).size(); i++) {


					System.out.println(memory.get(memory_index).get(i).toString());


				}


		}

		System.out.println("");
		System.out.println("");

	}

	/**
	 * Checks whether the family represented by a system of equations is already
	 * represented in the memory of previously seen systems of equations.
	 *
	 * @param memory a linked list of systems of equations previously encountered.
	 * @param equationList a system of equations to check.
	 * @return true/false true if already represented, false otherwise.
	 */
	public static boolean familyAlreadyRepresented(LinkedList<ArrayList<Equation>> memory, ArrayList<Equation> equationList){

		boolean mismatch = false;

		if (memory.size() > 0) {

			// will iterate through each equation set stored in memory
			for (int memory_index = 0; memory_index < memory.size(); memory_index++) {

				if(memory.get(memory_index).size() != equationList.size()){
					// If this equation set in memory has a set of equations that has a different
					// number of equations that equationList, then no match. Continue.
					continue;
				} else {


					// every time there is no match between an equation in memory and the entire
					// set in equationList, we break out of the for-loop. If we broke out of the
					// "i" for loop and mismatch is false, then we have a match and can return true;
					// If we never break out of the "i" for-loop with mismatch = false, then there is
					// no match and we return false.
					mismatch = false;

					// if the number of equations match, then check that each equation in equationList is
					// present in this location of the "memory" linked list
					for (int i = 0; i < memory.get(memory_index).size() & mismatch == false; i++) {



						for (int j = 0; j < equationList.size(); j++) {

							// If these two equations are equal, then no need to check against
							// the rest of the equations in equationList. Can move on to checking the
							// next equation in memory.
							if (equationList.get(j).map.equals(memory.get(memory_index).get(i).map)) {

								break;

							}
							// if the equations are not equal and all of the equationList equations have been checked against
							// this particular memory equation, then these sets are not equal. Need to move on to the next
							// location in memory
							else if(j == equationList.size() - 1){
								// setting mismatch to true will cause the "i" for-loop to break also.
								mismatch = true;
								break;
							}

						}

					}
					if (mismatch == false){
						//System.out.println("fAR returning true 1");
						//System.out.println(" =========== ");
						return true;

					}


				}

			}
			// if not matches resulted in returning true and all memory locations were checked,
			// then no match; return false
			//System.out.println("fAR returning false 1");
			//System.out.println(" =========== ");
			return false;
		}
		else{
			// if the program gets here, it means the "memory" linked list
			// is empty, so equationList is not represented
			//System.out.println("fAR returning false 2");
			//System.out.println(" =========== ");
			return false;
		}

	}


	/**
	 * Lets a user visualize what point is currently being
	 * considered by the auto generation algorithm by filling the
	 * current small box with an orange color.
	 */
	private static void placeOrangeFillOnCurrentPoint() {

		for (int topLeftBigBoxRow = 0; topLeftBigBoxRow < N * N; topLeftBigBoxRow = topLeftBigBoxRow + N) {

			for (int topLeftBigBoxColumn = 0; topLeftBigBoxColumn < N * N; topLeftBigBoxColumn = topLeftBigBoxColumn
					+ N) {

				Pseudoku.addUpBigBox(topLeftBigBoxRow, topLeftBigBoxColumn, true);

			}
		}

		Pseudoku.twoDArray[currentPoint.row][currentPoint.column].outline.setFill(Color.ORANGE);
	}

	// Returns next point that is non-immutable and non-blocked.
	/**
	 * Determines next point to modify during the auto generation process.
	 *
	 * @param twoDArray matrix being worked on during auto generation.
	 * @param currPoint current point being considered.
	 * @return the grid point to modify next.
	 */
	private static GridPoint getNextPoint(CustomBox[][] twoDArray, GridPoint currPoint) {

		/**
		 * First, we need to determine the row and column of the NEXT point to
		 * consider for non-immutability and non-blockage, given the current
		 * point specified in the parameters. Current point should not be
		 * considered. If current point were to considered, then infinite loops
		 * would result.
		 *
		 * Again, non-immutable means that it was specified by the user,
		 * directly or indirectly. Non-blocked means that previous values set by
		 * the algorithm have not forced a point to be zero, e.g., it's in a row
		 * where the reset of the values add up to N.
		 */

		// These variables represent the row and column of the NEXT point for
		// this method to consider. The only time that they would not simply
		// equal the point to the right of the current point is when the current
		// point is in the last column.
		int nextPointRow;
		int nextPointColumn;

		// if the current point is in the last column, then set the next point
		// to the first column of the next row. Unless this is the very last
		// point in the matrix, in which case there are no more points to
		// consider and the method can return an invalid GridPoint.
		if (currPoint.column == (N * N - 1)) {

			// if currentPoint is at the bottom right of the grid, then there
			// are no more points to return
			if (currPoint.row == (N * N - 1)) {

				// if no non-immutable, non-blocked point is not found, then the
				// method
				// sends a dummy point of -1, -1, -1 to notify the calling
				// instruction

				return new GridPoint(-1, -1, -1);

			} else {
				nextPointRow = currPoint.row + 1;
				nextPointColumn = 0;
			}

		}
		// if the current point is not in the last column, then keep
		// nextPointRow the same and set nextPointColumn to current column
		// incremented by 1
		else {
			nextPointRow = currPoint.row;
			nextPointColumn = currPoint.column + 1;
		}

		for (int i = nextPointRow; i < N * N; i++) {

			for (int j = nextPointColumn; j < N * N; j++) {


				// If the position is not immutable and is not part of a
				// completed row, column, or big box, then position is found.
				if (!twoDArray[i][j].immutable && !(twoDArray[i][j].outline.getFill() == Color.GREEN)
						&& (twoDArray[i][N * N].getValue() != N) && (twoDArray[N * N][j].getValue() != N)) {

					// System.out.println("");
					// System.out.println("getNextPoint returned " + i + ", " + j + ", " + twoDArray[i][j].getValue());
					// System.out.println("");

					// the value returned here is not significant, because it is
					// not used, but twoDArray[i][j].getValue() is returned as a
					// place holder .
					return new GridPoint(i, j, twoDArray[i][j].getValue());

				}

			} // end of inner for-loop

			// although in the row of the current point we only wanted to check everything to the right of the point, once we get to the next row, we want to check everything to the left and the right of the point, so we reset the next point column to 0
			nextPointColumn = 0;

		} // end of outer for-loop

		// if no non-immutable, non-blocked point is not found, then the method
		// sends a dummy point of -1, -1, -1 to notify the calling instruction


		return new GridPoint(-1, -1, -1);

	}

	// This function

	/**
	 * Finds the sum of the row/column/big block that contains the
	 * GridPoint parameter. It returns false if any sum is larger than N.
	 *
	 * @param pointToCheck the point to check
	 * @return true/false true if point is legal, false otherwise
	 */
	private static boolean legal(GridPoint pointToCheck) {

		// these variables keep track of the sum in their respective
		// row/column/big block, as indicated by the row and column of the
		// parameters. No sum can be larger than N for the parameter value to be
		// legal.
		int rowSum = 0;
		int columnSum = 0;
		int bigBoxSum = 0;

		// CHECK SUM OF THE ROW

		// check that this value does not result in a row that adds up to more
		// than N
		for (int c = 0; c < N * N; ++c) {
			if (c == pointToCheck.column) {
				rowSum = rowSum + pointToCheck.value;
			} else {
				rowSum = rowSum + Pseudoku.twoDArray[pointToCheck.row][c].getValue();
			}

		}

		if (rowSum > N) {
			return false;
		}

		// CHECK SUM OF THE COLUMN

		for (int r = 0; r < N * N; ++r) {

			if (r == pointToCheck.row) {
				columnSum = columnSum + pointToCheck.value;
			} else {
				columnSum = columnSum + Pseudoku.twoDArray[r][pointToCheck.column].getValue();
			}

		}

		if (columnSum > N) {
			return false;
		}

		// CHECK SUM OF THE BIG BOX

		// these two variables represent the top left corner of the big box
		// containing the row and column
		int startRow = 0;
		int startColumn = 0;

		// find top left corner of the big box containing the row and column
		// parameters
		while ((startRow + N) <= pointToCheck.row) {
			startRow = startRow + N;
		}
		while ((startColumn + N) <= pointToCheck.column) {
			startColumn = startColumn + N;
		}

		// check the big box
		for (int topLeftBigBoxRow = startRow; topLeftBigBoxRow < startRow + N; ++topLeftBigBoxRow) {

			for (int topLeftBigBoxColumn = startColumn; topLeftBigBoxColumn < startColumn + N; ++topLeftBigBoxColumn) {

				if (topLeftBigBoxRow == pointToCheck.row && topLeftBigBoxColumn == pointToCheck.column) {
					bigBoxSum = bigBoxSum + pointToCheck.value;
				} else {
					bigBoxSum = bigBoxSum + Pseudoku.twoDArray[topLeftBigBoxRow][topLeftBigBoxColumn].getValue();
				}

			}
		}

		if (bigBoxSum > N) {
			return false;
		}

		return true;
	}

	/**
	 * Calls the continueAutoGeneration method while the autogeneration
	 * is not done and not paused.
	 *
	 * @param twoDArray The matrix being operated on.
	 */
	public static void beginAutoGeneration(CustomBox[][] twoDArray) {

		while (!paused && !done) {
			continueAutoGeneration(Pseudoku.twoDArray);
		}

	}

	/**
	 * Pause the auto generation process.
	 *
	 */
	public static void pauseAutoGeneration() {

		// pauses auto-generation
		paused = true;

		// this is a "cheat" that pushes an invisible pause button on the pseudoku screen
		Pseudoku.pauseAutoGenerationButton.fire();


	}

	/**
	 * This method calls several helper methods so as to set
	 * grid boxes to immutable, as needed. Immutability means
	 * the box cannot be modified by the auto generation process.
	 *
	 * @param twoDArray the matrix being operated on.
	 */
	public static void setImmutability(CustomBox[][] twoDArray) {

		// The three functions below check whether certain small boxes have been
		// set as unchangeable by the user.
		checkBigBoxesForImmutability(twoDArray);
		checkRowsForImmutability(twoDArray);
		checkColumnsForImmutability(twoDArray);

		// display an informational message for the user
		Pseudoku.equationBox.getChildren().add(new Text("The pink boxes have been set as immutable."));
		Pseudoku.equationBox.getChildren().add(new Text("Their values will not be changing."));
		Pseudoku.equationBox.getChildren().add(new Text(""));
		Pseudoku.primaryStage.sizeToScene();

	}

	/**
	 * Checks columns in a matrix for immutability.
	 *
	 * @param twoDArray the matrix being operated on.
	 */
	public static void checkColumnsForImmutability(CustomBox[][] twoDArray) {

		for (int column = 0; column < N * N; ++column) {

			// if the summation box of the row equals N, then all the small
			// boxes of that row are immutable
			if (twoDArray[N * N][column].getValue() == N) {

				for (int row = 0; row < N * N; ++row) {
					twoDArray[row][column].immutable = true;
					twoDArray[row][column].outline.setFill(Color.RED);
				}

			}
		}
	}

	/**
	 * Checks rows in a matrix for immutability.
	 *
	 * @param twoDArray the matrix being operated on.
	 */
	public static void checkRowsForImmutability(CustomBox[][] twoDArray) {

		for (int row = 0; row < N * N; ++row) {

			// if the summation box of the row equals N, then all the small
			// boxes of that row are immutable
			if (twoDArray[row][N * N].getValue() == N) {

				for (int column = 0; column < N * N; ++column) {
					twoDArray[row][column].immutable = true;
					twoDArray[row][column].outline.setFill(Color.RED);
				}

			}
		}

	}

	/**
	 * Checks big boxes in a matrix for immutability.
	 *
	 * @param twoDArray the matrix being operated on.
	 */
	public static void checkBigBoxesForImmutability(CustomBox[][] twoDArray) {

		// the two outer for loops iterate through the top left corners of each
		// big box
		for (int topLeftBigBoxRow = 0; topLeftBigBoxRow < N * N; topLeftBigBoxRow = topLeftBigBoxRow + N) {

			for (int topLeftBigBoxColumn = 0; topLeftBigBoxColumn < N * N; topLeftBigBoxColumn = topLeftBigBoxColumn
					+ N) {

				// if the top-left small box of a big box is green, it means
				// that the who big box is green, and therefore, each of the
				// small boxes within the bix box is immutable
				if (twoDArray[topLeftBigBoxRow][topLeftBigBoxColumn].outline.getFill() == Color.GREEN) {

					// these two inner for loops iterate through each small box
					// of a given big box
					for (int i = topLeftBigBoxRow; i < topLeftBigBoxRow + N; i++) {

						for (int j = topLeftBigBoxColumn; j < topLeftBigBoxColumn + N; j++) {
							twoDArray[i][j].immutable = true;
							twoDArray[i][j].outline.setFill(Color.RED);
						}

					}
				}

			}
		}
	}


	/**
	 * This is a class that represents one grid point in the matrix.
	 * It is analogous to the custom box, but this allows a matrix to
	 * be operated on without necessarily changing what is displayed
	 * on the screen.
	 * <p>
	 * This is an inner class. Each gridPoint object will represent a small box
	 * on the grid, along with a value to try in that point during
	 * auto-generation. The point and value have not yet been tried, and are
	 * therefore created and subsequently stored in a stack.
	 *
	 * @author Eugene Prokopenko
	 */
	private static class GridPoint {

		public int row;
		public int column;
		public int value;

		public GridPoint(int row, int column, int value) {
			this.row = row;
			this.column = column;
			this.value = value;

		}

	}

}
